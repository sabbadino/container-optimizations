<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ALNS Container Viewer (Babylon.js)</title>
  <style>
  html, body { height: 100%; margin: 0; padding: 0; background: #ffffff; color: #1a1a1a; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    #toolbar { position: absolute; top: 8px; left: 8px; z-index: 10; background: rgba(20,22,28,0.85); border: 1px solid #2a2f3a; border-radius: 8px; padding: 8px 10px; display: flex; align-items: center; gap: 8px; backdrop-filter: blur(6px); }
    #toolbar button, #toolbar label { background: #1b1f2a; color: #e6e6e6; border: 1px solid #303642; border-radius: 6px; padding: 6px 10px; cursor: pointer; }
    #toolbar button:hover, #toolbar label:hover { background: #222838; }
    #toolbar input[type="file"] { display: none; }
    #info { font-size: 12px; opacity: 0.9; }
    #renderCanvas { width: 100%; height: 100%; display: block; }
  </style>
  <!-- Babylon.js CDN -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
  <div id="toolbar">
    <label for="fileInput">Load JSON…</label>
    <input id="fileInput" type="file" accept="application/json,.json" />
    <button id="resetCamera">Reset camera</button>
    <label><input type="checkbox" id="toggleContainer" checked /> Container</label>
    <label><input type="checkbox" id="toggleEdges" checked /> Box edges</label>
  <button id="toolNone">Tool: None</button>
  <button id="toolMove">Tool: Move</button>
  <button id="toolRotate">Tool: Rotate</button>
  <label><input type="checkbox" id="toggleSnap" checked /> Snap</label>
    <span id="info"></span>
  </div>
  <canvas id="renderCanvas"></canvas>

  <!-- Embed current output JSON to avoid CORS issues when opening this file locally -->
  <script id="alns-data" type="application/json">
  {
    "id": 1,
    "size": [10, 10, 10],
    "placements": [
      {"id":16,"position":[0,0,0],"orientation":0,"size":[5,5,5],"rotation_type":"fixed"},
      {"id":17,"position":[7,5,3],"orientation":2,"size":[2,2,3],"rotation_type":"free"},
      {"id":18,"position":[0,5,0],"orientation":0,"size":[5,5,5],"rotation_type":"fixed"},
      {"id":19,"position":[5,8,2],"orientation":0,"size":[2,2,2],"rotation_type":"fixed"},
      {"id":20,"position":[5,0,0],"orientation":0,"size":[5,5,5],"rotation_type":"fixed"},
      {"id":26,"position":[5,5,2],"orientation":0,"size":[1,1,1],"rotation_type":"fixed"},
      {"id":33,"position":[5,9,4],"orientation":0,"size":[1,1,1],"rotation_type":"fixed"},
      {"id":34,"position":[5,8,4],"orientation":0,"size":[1,1,1],"rotation_type":"fixed"},
      {"id":36,"position":[7,7,3],"orientation":0,"size":[3,3,3],"rotation_type":"fixed"},
      {"id":37,"position":[9,5,4],"orientation":3,"size":[1,2,2],"rotation_type":"free"},
      {"id":38,"position":[6,9,4],"orientation":0,"size":[1,1,1],"rotation_type":"fixed"},
      {"id":40,"position":[7,8,0],"orientation":3,"size":[3,2,3],"rotation_type":"free"},
      {"id":42,"position":[6,5,2],"orientation":0,"size":[1,1,1],"rotation_type":"fixed"},
      {"id":43,"position":[5,6,0],"orientation":5,"size":[2,2,3],"rotation_type":"free"},
      {"id":48,"position":[7,5,0],"orientation":0,"size":[3,3,3],"rotation_type":"fixed"},
      {"id":49,"position":[5,5,0],"orientation":3,"size":[2,1,2],"rotation_type":"free"},
      {"id":50,"position":[9,5,3],"orientation":0,"size":[1,1,1],"rotation_type":"fixed"},
      {"id":54,"position":[6,8,4],"orientation":5,"size":[1,1,2],"rotation_type":"free"},
      {"id":56,"position":[5,5,3],"orientation":1,"size":[2,3,3],"rotation_type":"free"},
      {"id":58,"position":[9,6,3],"orientation":0,"size":[1,1,1],"rotation_type":"fixed"},
      {"id":63,"position":[5,8,0],"orientation":0,"size":[2,2,2],"rotation_type":"fixed"}
    ],
    "status":"FEASIBLE"
  }
  </script>

  <script>
    // Basic error capture to surface issues in-page
    function updateInfo(text) {
      document.getElementById('info').textContent = text || '';
    }
    window.addEventListener('error', (e) => {
      updateInfo('Error: ' + (e?.message || 'Unknown error'));
    });
    window.addEventListener('unhandledrejection', (e) => {
      const msg = (e && (e.reason?.message || e.reason)) || 'Unknown rejection';
      updateInfo('Unhandled promise rejection: ' + msg);
    });

    // Utility: simple seeded color based on id
    function colorFromId(id) {
      const hue = (id * 47) % 360; // pseudo-random but consistent
      const sat = 0.7, val = 0.95;
      const c = val * sat;
      const x = c * (1 - Math.abs(((hue / 60) % 2) - 1));
      const m = val - c;
      let r=0,g=0,b=0;
      if (hue < 60) [r,g,b] = [c,x,0];
      else if (hue < 120) [r,g,b] = [x,c,0];
      else if (hue < 180) [r,g,b] = [0,c,x];
      else if (hue < 240) [r,g,b] = [0,x,c];
      else if (hue < 300) [r,g,b] = [x,0,c];
      else [r,g,b] = [c,0,x];
      return new BABYLON.Color3(r + m, g + m, b + m);
    }

  const canvas = document.getElementById('renderCanvas');
  let engine, scene, camera;
  let containerMesh = null;
  let boxesParent = null;
  let axesViewer = null;
  let axesLabels = [];
  let currentContainerSize = null; // [L,W,H]
  let axesRoot = null; // transform node anchoring axes at container center
  let highlightLayer = null;
  let gizmoManager = null;
  let selectedMesh = null;
  let currentTool = 'none';
  const moveSnap = 1;           // units
  const rotateSnap = Math.PI/2; // 90 degrees
  // Gizmo wiring flags and last valid transform
  let gizmoPositionWired = false;
  let gizmoRotationWired = false;
  let lastValidTransform = null; // { position: Vector3, rotation: Vector3 | Quaternion }

    function createScene() {
      scene = new BABYLON.Scene(engine);
  scene.clearColor = new BABYLON.Color4(1, 1, 1, 1);

  camera = new BABYLON.ArcRotateCamera('camera', -Math.PI / 2.2, Math.PI / 3, 30, new BABYLON.Vector3(0, 0, 0), scene);
  // Use Z-up convention
  camera.upVector = new BABYLON.Vector3(0, 0, 1);
      camera.attachControl(canvas, true);
      camera.wheelPrecision = 50; // smoother zoom
      camera.panningSensibility = 50;

      const light = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0.3, 1, -0.3), scene);
      light.intensity = 0.9;

      const env = scene.createDefaultEnvironment({
        createSkybox: false,
        createGround: false,
      });

  // Highlight layer for selection
  highlightLayer = new BABYLON.HighlightLayer('hl', scene);
  // Gizmo manager for move/rotate
  gizmoManager = new BABYLON.GizmoManager(scene);
  gizmoManager.usePointerToAttachGizmos = false;
  gizmoManager.positionGizmoEnabled = false;
  gizmoManager.rotationGizmoEnabled = false;
  if (gizmoManager.gizmos?.positionGizmo) gizmoManager.gizmos.positionGizmo.snapDistance = moveSnap;
  if (gizmoManager.gizmos?.rotationGizmo) gizmoManager.gizmos.rotationGizmo.snapDistance = rotateSnap;

  // Ensure drag observables are wired
  ensureGizmoObservables();

      return scene;
    }

    function toCenterPosition(posLWH, sizeLWH) {
      // Map (L,W,H) to Babylon (X,Y,Z) with Z-up, converting corner -> center
      const [L, W, H] = sizeLWH;
      const [pL, pW, pH] = posLWH;
      return new BABYLON.Vector3(
        pL + L / 2, // X (length)
        pW + W / 2, // Y (width)
        pH + H / 2  // Z (height, up)
      );
    }

    function buildContainerAndBoxes(data) {
      // Cleanup old meshes
      if (boxesParent) boxesParent.dispose();
      if (containerMesh) containerMesh.dispose();
  // Dispose axes to recreate with new scale
  disposeAxes();

      boxesParent = new BABYLON.TransformNode('boxesParent', scene);

      // Container
      const [L, W, H] = data.size; // L,W,H
      containerMesh = BABYLON.MeshBuilder.CreateBox('container', {
        width: L,  // X (length)
        height: W, // Y (width)
        depth: H,  // Z (height)
        updatable: false
      }, scene);
      // Move container so its corner is at (0,0,0), not centered at origin
      containerMesh.position = toCenterPosition([0,0,0], [L,W,H]);

      // Transparent box + edges for container
      const contMat = new BABYLON.StandardMaterial('containerMat', scene);
      contMat.diffuseColor = new BABYLON.Color3(0.3, 0.7, 1.0);
      contMat.alpha = 0.05;
      contMat.specularColor = BABYLON.Color3.Black();
      containerMesh.material = contMat;
  containerMesh.isPickable = false;
      containerMesh.enableEdgesRendering();
      containerMesh.edgesWidth = 1.5;
      containerMesh.edgesColor = new BABYLON.Color4(0.3, 0.7, 1.0, 0.8);

      // Placements drive actual oriented size/position
      const placements = Array.isArray(data.placements) ? data.placements : [];

      const boxMatCache = new Map();
      function getMatFor(id) {
        const key = id;
        if (boxMatCache.has(key)) return boxMatCache.get(key);
        const mat = new BABYLON.StandardMaterial(`mat-${key}`);
        mat.diffuseColor = colorFromId(key);
        mat.specularColor = new BABYLON.Color3(0.06,0.06,0.06);
        mat.emissiveColor = new BABYLON.Color3(0.02,0.02,0.02);
  mat.alpha = 0.5; // 50% transparency for boxes
        boxMatCache.set(key, mat);
        return mat;
      }

      for (const p of placements) {
        const [l, w, h] = p.size; // oriented sizes in L,W,H
        const mesh = BABYLON.MeshBuilder.CreateBox(`box-${p.id}` , {
          width: l,   // X
          height: w,  // Y
          depth: h,   // Z (up)
          updatable: false
        }, scene);
        mesh.position = toCenterPosition(p.position, [l,w,h]);
  mesh.material = getMatFor(p.id);
        mesh.parent = boxesParent;
        mesh.enableEdgesRendering();
        mesh.edgesWidth = 1.0;
        mesh.edgesColor = new BABYLON.Color4(0,0,0,0.85);
  mesh.metadata = { id: p.id, size: [l,w,h], pos: p.position };
      }

      // Frame camera to container
      frameCameraTo(L, W, H);

  // Remember container size for axes scaling and recreate axes if toggle is on (default on)
  currentContainerSize = [L, W, H];
  const axesToggleEl = document.getElementById('toggleAxes');
  const showAxes = !axesToggleEl || axesToggleEl.checked; // default on if missing
  if (showAxes) createAxesForCurrent();

      updateInfo(`Container: ${L} x ${W} x ${H} • Boxes: ${placements.length} • Status: ${data.status || 'N/A'}`);
    }

    function frameCameraTo(L, W, H) {
      const target = toCenterPosition([0,0,0], [L,W,H]);
      camera.setTarget(target);
      const radius = Math.max(L, W, H) * 2.2;
      camera.radius = radius;
      camera.alpha = -Math.PI/3;
      camera.beta = Math.PI/3;
    }

    // UI wiring
    function wireUi() {
      document.getElementById('resetCamera').addEventListener('click', () => {
        if (!containerMesh) return;
        const bb = containerMesh.getBoundingInfo().boundingBox;
        const extents = bb.maximumWorld.subtract(bb.minimumWorld);
        // extents.x->L, extents.y->W, extents.z->H in Z-up mapping
        frameCameraTo(extents.x, extents.y, extents.z);
      });

      const toggleContainer = document.getElementById('toggleContainer');
      toggleContainer.addEventListener('change', (e) => {
        if (containerMesh) containerMesh.setEnabled(e.target.checked);
      });

      const toggleEdges = document.getElementById('toggleEdges');
      toggleEdges.addEventListener('change', (e) => {
        const show = e.target.checked;
        if (!boxesParent) return;
        boxesParent.getChildMeshes().forEach(m => {
          if (show) {
            if (!m.edgesRenderer) m.enableEdgesRendering();
          } else {
            if (m.edgesRenderer) m.disableEdgesRendering();
          }
        });
      });

      // Tool buttons and snapping
      document.getElementById('toolNone').addEventListener('click', () => setTool('none'));
      document.getElementById('toolMove').addEventListener('click', () => setTool('move'));
      document.getElementById('toolRotate').addEventListener('click', () => setTool('rotate'));
      document.getElementById('toggleSnap').addEventListener('change', (e) => {
        const on = e.target.checked;
        if (gizmoManager.gizmos?.positionGizmo) gizmoManager.gizmos.positionGizmo.snapDistance = on ? moveSnap : 0;
        if (gizmoManager.gizmos?.rotationGizmo) gizmoManager.gizmos.rotationGizmo.snapDistance = on ? rotateSnap : 0;
      });

      // Axes toggle injected next to toolbar if not present
      if (!document.getElementById('toggleAxes')) {
        const label = document.createElement('label');
        label.innerHTML = '<input type="checkbox" id="toggleAxes" checked /> Axes';
        document.getElementById('toolbar').insertBefore(label, document.getElementById('info'));
        const input = label.querySelector('input');
        input.addEventListener('change', (e) => {
          const show = e.target.checked;
          if (show) createAxesForCurrent(); else disposeAxes();
        });
      }

      const fileInput = document.getElementById('fileInput');
      fileInput.addEventListener('change', async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        try {
          let text = await file.text();
          // Strip BOM and trim
          if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1);
          text = text.trim();
          const raw = JSON.parse(text);
          const normalized = normalizeSchema(raw); // will throw if invalid
          buildContainerAndBoxes(normalized);
          updateInfo(`Loaded ${file.name} • Container ${normalized.size.join('x')} • Boxes: ${(normalized.placements||[]).length}`);
        } catch (err) {
          console.error(err);
          updateInfo('Failed to load JSON: ' + (err?.message || err));
        }
      });

      // Hover tooltip in console
      scene.onPointerObservable.add((pointerInfo) => {
        if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERMOVE) {
          const pick = scene.pick(scene.pointerX, scene.pointerY);
          if (pick?.hit && pick.pickedMesh && pick.pickedMesh.metadata?.id) {
            const md = pick.pickedMesh.metadata;
            updateInfo(`Box ${md.id}${md.groupId !== undefined ? ' (group ' + md.groupId + ')' : ''} • size ${md.size.join('x')} @ [${md.pos.join(', ')}]`);
          }
        }
      });

      // Click to select/deselect
      scene.onPointerObservable.add((pointerInfo) => {
        if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
          const pick = scene.pick(scene.pointerX, scene.pointerY);
          if (!pick?.hit) {
            // Clicked empty space: deselect
            deselectMesh();
            return;
          }
          if (pick.pickedMesh?.name?.startsWith('box-')) {
            selectMesh(pick.pickedMesh);
            return;
          }
          // Otherwise (e.g., gizmo handles, utility layer meshes), keep current selection
        }
      });
    }

    // Boot with guard for missing Babylon (e.g., CDN blocked)
    function boot() {
      if (typeof BABYLON === 'undefined') {
        updateInfo('Babylon.js failed to load. Check internet access to cdn.babylonjs.com or use a local copy.');
        console.error('Babylon.js is undefined.');
        return;
      }
      engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, antialias: true });
      scene = createScene();
      wireUi();

      try {
  const embedded = document.getElementById('alns-data').textContent;
  const data = JSON.parse(embedded);
  const normalized = normalizeSchema(data) || data;
  buildContainerAndBoxes(normalized);
      } catch (err) {
        console.error(err);
        updateInfo('Failed to parse embedded data');
      }

      engine.runRenderLoop(() => scene.render());
      window.addEventListener('resize', () => engine.resize());
    }

    boot();

    // Keep selected mesh inside container when moving
    function clampMeshInsideContainer(mesh) {
      if (!mesh || !currentContainerSize) return;
      const [L, W, H] = currentContainerSize;
      // Ensure bounds are current
      mesh.computeWorldMatrix(true);
      const bb = mesh.getBoundingInfo().boundingBox;
      const min = bb.minimumWorld;
      const max = bb.maximumWorld;
      let dx = 0, dy = 0, dz = 0;
      if (min.x < 0) dx = -min.x; else if (max.x > L) dx = L - max.x;
      if (min.y < 0) dy = -min.y; else if (max.y > W) dy = W - max.y;
      if (min.z < 0) dz = -min.z; else if (max.z > H) dz = H - max.z;
      if (dx || dy || dz) mesh.position.addInPlace(new BABYLON.Vector3(dx, dy, dz));
    }

    // Per-frame clamp during move tool
    function startClampLoop() {
      if (!scene) return;
      scene.onBeforeRenderObservable.add(() => {
        if (selectedMesh && currentTool === 'move') clampMeshInsideContainer(selectedMesh);
      });
    }

    // Selection helpers
    function setTool(mode) {
      currentTool = mode;
      if (!gizmoManager) return;
      gizmoManager.positionGizmoEnabled = mode === 'move';
      gizmoManager.rotationGizmoEnabled = mode === 'rotate';
  // Make sure observables are set when gizmos are created on-demand
  ensureGizmoObservables();
    }

    function selectMesh(mesh) {
      if (selectedMesh === mesh) return;
      deselectMesh();
      selectedMesh = mesh;
      try { highlightLayer.addMesh(mesh, new BABYLON.Color3(1, 1, 0)); } catch {}
      if (gizmoManager) gizmoManager.attachToMesh(mesh);
      // Respect current tool
      setTool(currentTool);
    }

    function deselectMesh() {
      if (!selectedMesh) return;
      try { highlightLayer.removeMesh(selectedMesh); } catch {}
      selectedMesh = null;
      if (gizmoManager) gizmoManager.attachToMesh(null);
    }

    // --- Overlap prevention utilities ---
    function ensureGizmoObservables() {
      if (!gizmoManager) return;
      // Position gizmo
      const pg = gizmoManager.gizmos?.positionGizmo;
      if (pg && !gizmoPositionWired) {
        gizmoPositionWired = true;
        pg.onDragStartObservable.add(() => { captureLastTransform(); });
        pg.onDragEndObservable.add(() => { handleDragEndValidation(); });
      }
      // Rotation gizmo
      const rg = gizmoManager.gizmos?.rotationGizmo;
      if (rg && !gizmoRotationWired) {
        gizmoRotationWired = true;
        rg.onDragStartObservable.add(() => { captureLastTransform(); });
        rg.onDragEndObservable.add(() => { handleDragEndValidation(); });
      }
    }

    function captureLastTransform() {
      if (!selectedMesh) { lastValidTransform = null; return; }
      const pos = selectedMesh.position.clone();
      let rot = null;
      if (selectedMesh.rotationQuaternion) rot = selectedMesh.rotationQuaternion.clone();
      else rot = selectedMesh.rotation.clone();
      lastValidTransform = { position: pos, rotation: rot };
    }

    function restoreLastTransform() {
      if (!selectedMesh || !lastValidTransform) return;
      selectedMesh.position.copyFrom(lastValidTransform.position);
      if (selectedMesh.rotationQuaternion && lastValidTransform.rotation instanceof BABYLON.Quaternion) {
        selectedMesh.rotationQuaternion.copyFrom(lastValidTransform.rotation);
      } else if (!(lastValidTransform.rotation instanceof BABYLON.Quaternion)) {
        selectedMesh.rotation.copyFrom(lastValidTransform.rotation);
      } else {
        // Convert quaternion to Euler if needed
        const e = lastValidTransform.rotation.toEulerAngles();
        selectedMesh.rotation.copyFrom(e);
      }
      selectedMesh.computeWorldMatrix(true);
    }

    function handleDragEndValidation() {
      if (!selectedMesh) return;
  // Quantize rotation to nearest 90° per axis before validation
  quantizeRotationToRightAngles(selectedMesh);
      // If overlaps with any other box, revert
      const overlapWith = intersectsAnyBox(selectedMesh);
      if (overlapWith) {
        restoreLastTransform();
        updateInfo(`Move/Rotate invalid: overlaps with box ${overlapWith.metadata?.id ?? overlapWith.name}. Reverting.`);
        return;
      }
      // Otherwise, accept and update metadata (corner position and oriented size)
      updateMeshMetadataFromWorld(selectedMesh);
    }

    function getBoxMeshes() {
      if (!boxesParent) return [];
      return boxesParent.getChildMeshes().filter(m => m && m.metadata && m.name?.startsWith('box-'));
    }

    function getOBB(mesh) {
      mesh.computeWorldMatrix(true);
      const wm = mesh.getWorldMatrix();
      const rot = wm.getRotationMatrix();
      const center = mesh.getAbsolutePosition().clone(); // center of box
      const sx = mesh.scaling?.x ?? 1, sy = mesh.scaling?.y ?? 1, sz = mesh.scaling?.z ?? 1;
      const size = (mesh.metadata?.size && mesh.metadata.size.length === 3) ? mesh.metadata.size : [
        mesh.getBoundingInfo().boundingBox.extendSizeWorld.x * 2,
        mesh.getBoundingInfo().boundingBox.extendSizeWorld.y * 2,
        mesh.getBoundingInfo().boundingBox.extendSizeWorld.z * 2,
      ];
      const half = [0.5 * size[0] * sx, 0.5 * size[1] * sy, 0.5 * size[2] * sz];
      const ax = BABYLON.Vector3.TransformNormal(BABYLON.Axis.X, rot).normalize();
      const ay = BABYLON.Vector3.TransformNormal(BABYLON.Axis.Y, rot).normalize();
      const az = BABYLON.Vector3.TransformNormal(BABYLON.Axis.Z, rot).normalize();
      return { center, axes: [ax, ay, az], half };
    }

    function projectRadius(axes, half, L) {
      // Sum of half extents projected onto axis L
      return Math.abs(BABYLON.Vector3.Dot(axes[0], L)) * half[0]
           + Math.abs(BABYLON.Vector3.Dot(axes[1], L)) * half[1]
           + Math.abs(BABYLON.Vector3.Dot(axes[2], L)) * half[2];
    }

    function obbOverlapSAT(a, b) {
      // Based on standard 3D OBB SAT: test axes A0..A2, B0..B2, and cross products Ai x Bj
      const T = b.center.subtract(a.center);
      const axesToTest = [];
      for (let i=0;i<3;i++) axesToTest.push(a.axes[i]);
      for (let i=0;i<3;i++) axesToTest.push(b.axes[i]);
      for (let i=0;i<3;i++) {
        for (let j=0;j<3;j++) {
          const c = BABYLON.Vector3.Cross(a.axes[i], b.axes[j]);
          if (c.lengthSquared() > 1e-10) axesToTest.push(c.normalize());
        }
      }
      for (const L of axesToTest) {
        const ra = projectRadius(a.axes, a.half, L);
        const rb = projectRadius(b.axes, b.half, L);
        const dist = Math.abs(BABYLON.Vector3.Dot(T, L));
        if (dist > ra + rb - 1e-9) return false; // separated on L (allow touching)
      }
      return true; // overlap or touch inside tolerance
    }

    function intersectsAnyBox(mesh) {
      const obbA = getOBB(mesh);
      const boxes = getBoxMeshes();
      for (const other of boxes) {
        if (other === mesh) continue;
        const obbB = getOBB(other);
        if (obbOverlapSAT(obbA, obbB)) return other;
      }
      return null;
    }

    function updateMeshMetadataFromWorld(mesh) {
      // Update corner position in LWH using world AABB min. Keep original size.
      const bb = mesh.getBoundingInfo().boundingBox;
      const min = bb.minimumWorld;
      const pos = [min.x, min.y, min.z]; // corner at world origin-based container
      if (!mesh.metadata) mesh.metadata = {};
      mesh.metadata.pos = pos;
    }

    // --- Rotation quantization (90° multiples) ---
    function snapAngle(angle, step) {
      return Math.round(angle / step) * step;
    }

    function quantizeRotationToRightAngles(mesh) {
      const step = Math.PI / 2; // 90 degrees
      if (mesh.rotationQuaternion) {
        const e = mesh.rotationQuaternion.toEulerAngles();
        const rx = snapAngle(e.x, step);
        const ry = snapAngle(e.y, step);
        const rz = snapAngle(e.z, step);
        mesh.rotationQuaternion = BABYLON.Quaternion.FromEulerAngles(rx, ry, rz);
      } else if (mesh.rotation) {
        mesh.rotation.x = snapAngle(mesh.rotation.x, step);
        mesh.rotation.y = snapAngle(mesh.rotation.y, step);
        mesh.rotation.z = snapAngle(mesh.rotation.z, step);
      }
      mesh.computeWorldMatrix(true);
    }

    function disposeAxes() {
      if (axesViewer) { axesViewer.dispose(); axesViewer = null; }
      for (const m of axesLabels) { try { m.dispose(); } catch {} }
      axesLabels = [];
  if (axesRoot) { try { axesRoot.dispose(); } catch {} axesRoot = null; }
    }

    function createAxesForCurrent() {
      if (!scene) return;
      disposeAxes();
      const [L, W, H] = currentContainerSize || [10,10,10];
  // Z-up: X=L, Y=W, Z=H
  const lenX = Math.max(0.5, L * 1.1);
  const lenY = Math.max(0.5, W * 1.1);
  const lenZ = Math.max(0.5, H * 1.1);
  const coneHX = Math.max(0.2, lenX * 0.08);
  const coneHY = Math.max(0.2, lenY * 0.08);
  const coneHZ = Math.max(0.2, lenZ * 0.08);
      const origin = BABYLON.Vector3.Zero();
      axesRoot = new BABYLON.TransformNode('axesRoot', scene);
      axesRoot.position = origin;

      const matX = new BABYLON.StandardMaterial('matX', scene); matX.emissiveColor = new BABYLON.Color3(1,0.3,0.3); matX.specularColor = BABYLON.Color3.Black();
      const matY = new BABYLON.StandardMaterial('matY', scene); matY.emissiveColor = new BABYLON.Color3(0.3,1,0.3); matY.specularColor = BABYLON.Color3.Black();
      const matZ = new BABYLON.StandardMaterial('matZ', scene); matZ.emissiveColor = new BABYLON.Color3(0.3,0.6,1); matZ.specularColor = BABYLON.Color3.Black();

      // X axis
      const xLine = BABYLON.MeshBuilder.CreateLines('xLine', { points: [new BABYLON.Vector3(0,0,0), new BABYLON.Vector3(lenX,0,0)], colors: [new BABYLON.Color4(1,0.3,0.3,1), new BABYLON.Color4(1,0.3,0.3,1)] }, scene);
      xLine.parent = axesRoot; xLine.isPickable = false;
      const xCone = BABYLON.MeshBuilder.CreateCylinder('xCone', { height: coneHX, diameterTop: 0, diameterBottom: coneHX * 0.4, tessellation: 16 }, scene);
      xCone.material = matX; xCone.isPickable = false; xCone.rotation.z = -Math.PI/2; xCone.position = new BABYLON.Vector3(lenX + coneHX/2, 0, 0); xCone.parent = axesRoot;

      // Y axisz
  const yLine = BABYLON.MeshBuilder.CreateLines('yLine', { points: [new BABYLON.Vector3(0,0,0), new BABYLON.Vector3(0,lenY,0)], colors: [new BABYLON.Color4(0.3,1,0.3,1), new BABYLON.Color4(0.3,1,0.3,1)] }, scene);
      yLine.parent = axesRoot; yLine.isPickable = false;
      const yCone = BABYLON.MeshBuilder.CreateCylinder('yCone', { height: coneHY, diameterTop: 0, diameterBottom: coneHY * 0.4, tessellation: 16 }, scene);
      yCone.material = matY; yCone.isPickable = false; yCone.position = new BABYLON.Vector3(0, lenY + coneHY/2, 0); yCone.parent = axesRoot;

      // Z axis
  const zLine = BABYLON.MeshBuilder.CreateLines('zLine', { points: [new BABYLON.Vector3(0,0,0), new BABYLON.Vector3(0,0,lenZ)], colors: [new BABYLON.Color4(0.3,0.6,1,1), new BABYLON.Color4(0.3,0.6,1,1)] }, scene);
      zLine.parent = axesRoot; zLine.isPickable = false;
      const zCone = BABYLON.MeshBuilder.CreateCylinder('zCone', { height: coneHZ, diameterTop: 0, diameterBottom: coneHZ * 0.4, tessellation: 16 }, scene);
      zCone.material = matZ; zCone.isPickable = false; zCone.rotation.x = Math.PI/2; zCone.position = new BABYLON.Vector3(0, 0, lenZ + coneHZ/2); zCone.parent = axesRoot;

      // Labels beyond tips
      axesLabels.push(createAxisLabel('X', new BABYLON.Vector3(lenX + coneHX + coneHX*0.5, 0, 0), matX.emissiveColor));
      axesLabels.push(createAxisLabel('Y', new BABYLON.Vector3(0, lenY + coneHY + coneHY*0.5, 0), matY.emissiveColor));
      axesLabels.push(createAxisLabel('Z', new BABYLON.Vector3(0, 0, lenZ + coneHZ + coneHZ*0.5), matZ.emissiveColor));
    }

    function placeAxisLabels(scale) {
      const padAbs = Math.max(0.1, scale * 0.25);
      // Ensure world matrices are up to date
      axesRoot?.computeWorldMatrix(true);
      if (axesViewer?.xAxisArrow && axesLabels[0]) {
        axesViewer.xAxisArrow.computeWorldMatrix(true);
        const max = axesViewer.xAxisArrow.getBoundingInfo().boundingBox.maximumWorld;
        axesLabels[0].position.set(max.x + padAbs, max.y, max.z);
      }
      if (axesViewer?.yAxisArrow && axesLabels[1]) {
        axesViewer.yAxisArrow.computeWorldMatrix(true);
        const max = axesViewer.yAxisArrow.getBoundingInfo().boundingBox.maximumWorld;
        axesLabels[1].position.set(max.x, max.y + padAbs, max.z);
      }
      if (axesViewer?.zAxisArrow && axesLabels[2]) {
        axesViewer.zAxisArrow.computeWorldMatrix(true);
        const max = axesViewer.zAxisArrow.getBoundingInfo().boundingBox.maximumWorld;
        axesLabels[2].position.set(max.x, max.y, max.z + padAbs);
      }
    }

    function createAxisLabel(text, position, color) {
      const plane = BABYLON.MeshBuilder.CreatePlane('label-'+text, { size: 0.6 }, scene);
      const dt = new BABYLON.DynamicTexture('dt-'+text, {width:256, height:256}, scene, true);
      const ctx = dt.getContext();
      ctx.clearRect(0,0,256,256);
      ctx.font = 'bold 160px Segoe UI';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = 'rgba(0,0,0,0.0)';
      ctx.fillRect(0,0,256,256);
      ctx.fillStyle = '#ffffff';
      ctx.strokeStyle = 'rgba(0,0,0,0.5)';
      ctx.lineWidth = 12;
      ctx.strokeText(text, 128, 140);
      ctx.fillText(text, 128, 140);
      dt.update();
      const mat = new BABYLON.StandardMaterial('mat-'+text, scene);
      mat.diffuseTexture = dt;
      mat.emissiveColor = color || new BABYLON.Color3(1,1,1);
      mat.backFaceCulling = false;
      mat.specularColor = BABYLON.Color3.Black();
      mat.alpha = 0.9;
      plane.material = mat;
      plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
      plane.position = position;
      return plane;
    }

    // Normalize JSON into { size: [L,W,H], placements: [...] } (boxes removed from schema)
    function normalizeSchema(raw) {
      if (!raw) return null;
      // If top-level is an array, try first element
      if (Array.isArray(raw)) raw = raw[0];
      if (!raw || typeof raw !== 'object') return null;

      let size = parseSize(raw.size) || parseSize(raw.container?.size) || parseSize(raw.dimensions) || parseSize(raw.container_dimensions);

      const out = { id: raw.id, size, status: raw.status };
      const placements = arr(raw.placements) || arr(raw.results?.placements) || arr(raw.Placements) || null;

      // Require placements
      if (!placements || placements.length === 0) {
        throw new Error("Required 'placements' array not found or empty.");
      }

      out.placements = placements.map(p => normalizePlacement(p));
      if (!size) out.size = deriveContainerSizeFromPlacements(out.placements);
      if (!out.size) {
        throw new Error("Required 'size' not found and could not be derived from placements.");
      }
      return out;
    }

    function arr(v) { return Array.isArray(v) ? v : null; }
    function num(v) { return (typeof v === 'number' && Number.isFinite(v)) ? v : (typeof v === 'string' && v.trim() !== '' && !isNaN(+v) ? +v : undefined); }
    function str(v) { return (typeof v === 'string' && v.trim() !== '') ? v : undefined; }

    function parseSize(v) {
      if (!v) return null;
      if (Array.isArray(v) && v.length === 3) return v.map(Number);
      if (typeof v === 'object') {
        const L = num(v.L ?? v.l ?? v.length);
        const W = num(v.W ?? v.w ?? v.width);
        const H = num(v.H ?? v.h ?? v.height);
        if ([L,W,H].every(x => typeof x === 'number')) return [L,W,H];
      }
      if (typeof v === 'string') {
        const parts = v.split(/[x,; ]+/).map(s => s.trim()).filter(Boolean);
        if (parts.length === 3 && parts.every(p => !isNaN(+p))) return parts.map(p => +p);
      }
      return null;
    }

    function parsePosition(v) {
      if (!v) return null;
      if (Array.isArray(v) && v.length === 3) return v.map(Number);
      if (typeof v === 'object') {
        const L = num(v.L ?? v.x ?? v.l);
        const W = num(v.W ?? v.z ?? v.w);
        const H = num(v.H ?? v.y ?? v.h);
        if ([L,W,H].every(x => typeof x === 'number')) return [L,W,H];
      }
      if (typeof v === 'string') {
        const parts = v.split(/[x,;, ]+/).map(s => s.trim()).filter(Boolean);
        if (parts.length === 3 && parts.every(p => !isNaN(+p))) return parts.map(p => +p);
      }
      return null;
    }

    function normalizePlacement(p) {
      const pos = parsePosition(p.position) || parsePosition(p.pos) || [0,0,0];
      const size = parseSize(p.size) || [0,0,0];
      const orientation = num(p.orientation);
      return { id: p.id, position: pos, size, orientation: orientation ?? 0, rotation_type: p.rotation_type || 'fixed' };
    }

    function deriveContainerSizeFromPlacements(pls) {
      if (!Array.isArray(pls) || !pls.length) return null;
      let maxL = 0, maxW = 0, maxH = 0;
      for (const p of pls) {
        const pos = p.position; // [L,W,H] corner
        const sz = p.size;      // [L,W,H]
        if (!pos || !sz) continue;
        maxL = Math.max(maxL, Number(pos[0]) + Number(sz[0]));
        maxW = Math.max(maxW, Number(pos[1]) + Number(sz[1]));
        maxH = Math.max(maxH, Number(pos[2]) + Number(sz[2]));
      }
      if (maxL && maxW && maxH) return [maxL, maxW, maxH];
      return null;
    }

    // Map size [L,W,H] by orientation. If desc provided (e.g., "L,W,H", "W,L,H", "H,W,L"), use it.
    function applyOrientation(size, orientation, desc) {
      const [L, W, H] = size;
      if (typeof desc === 'string') {
        const parts = desc.split(',').map(s => s.trim().toUpperCase());
        const order = parts.map(p => (p === 'L' ? L : p === 'W' ? W : H));
        return order;
      }
      // Fallback mapping for integer orientation codes if needed (0..5 common)
      const maps = [
        [L, W, H], // 0: L,W,H
        [L, H, W], // 1: L,H,W
        [W, L, H], // 2: W,L,H
        [W, H, L], // 3: W,H,L
        [H, L, W], // 4: H,L,W
        [H, W, L], // 5: H,W,L
      ];
      if (Number.isInteger(orientation) && orientation >= 0 && orientation < maps.length) return maps[orientation];
      return [L, W, H];
    }
  </script>
</body>
</html>
